import { processVault } from "core/processVault";
import { parseRebateDeals } from "parsing/parseRebateDeals";
import { parseOffchainReferrals } from "parsing/parseOffchainReferrals";
import { parseVaultArgument } from "parsing/parseVault";
import type { Command } from "@commander-js/extra-typings";
import { filterWildCard } from "utils/various";
import type { ProcessVaultReturn } from "core/types";
import type { Vault } from "types/Vault";

export function setUserFeeCommand(command: Command) {
  command
    .command("user-fee")
    .alias("uf")
    .description(
      "Calculate and generate fee reports for a specified vault, including referral rewards and rebates for all users. \
The output is a csv with the following columns: chainId, vault, wallet, balance, fees, pricePerShare, cashback. \
This command require precise block input. The fromBlock and the toBlock must correspond to totalAssets updates blockNumber.\n"
    )
    .argument(
      "chainId:VaultAddress",
      "The chain ID and vault address to find blocks for\n",
      parseVaultArgument
    )
    .requiredOption(
      "-f, --from-block <number>",
      "Starting block number for fee computation (exclusive). Use 'find-blocks' command to find the appropriate block number\n"
    )
    .requiredOption(
      "-t, --to-block <number>",
      "Ending block number for fee computation (inclusive). Use 'find-blocks' command to find the appropriate block number\n"
    )
    .option(
      "-r, --readable",
      "Format the output in a human-readable format\n",
      false
    )
    .option(
      "-o, --output",
      "Will save the result in output/user-fee in a file with following format: <chainId>-<vaultAddress>-<from-block>-<to-block>.csv"
    )
    .option(
      "--silent",
      "This will prevent the printing of the output on stdout\n",
      false
    )
    .option(
      "-d, --deals <string>",
      `Path to the csv file containing OTC (Over-The-Counter) deals on the fee rebate. \
The amount of % is express in 10^2. For example, 8% is express 800 in the csv file. \
A fee rebate means that the user will be refunded a percentage of the fees he paid. \
0, 0x0 is a wildcard for all vaults on any chain. \
Format: chainId,vault,address,rebateRateBps \
Example:  1,0x07ed4...cb90D9B,0x123456...67890,1000\n`,
      parseRebateDeals
    )
    .option(
      "--referrals <string>",
      `Path to the csv file containing OTC (Over-The-Counter) referrals on the fee rewards. \
The amount of % is express in 10^2. For example, 8% is express 800 in the csv file. \
Those referrals will overwrite the on-chain referrals. \
A fee reward means that the user will be rewarded a percentage of the fees generated by the referred user. \
0, 0x0 is a wildcard for all vaults on any chain. \
Format: chainId,vault,referrer,referree,rewardRateBps,rebateRateBps \
Example:  1,0x07ed4...cb90D9B,0x123456...67890,0x6789...123456,1000,1000\n`,
      parseOffchainReferrals
    )
    .option(
      "--fee-rebate-rate <number>",
      "Bips of fees to be refunded to the referred user (e.g., 500 means 5% of fees are refunded, 5 means 0.05% of fees are refunded)\n",
      "500"
    )
    .option(
      "--fee-reward-rate <number>",
      "Bips of fees to be distributed to the referrer (e.g., 1500 means referrer receives 15% of fees generated by the referred user). \
When a user refer another user, he become his lifetime referrer. We do not overwrite referals.\n",
      "1500"
    )
    .addHelpText(
      "after",
      `
Example:
  $ bun user-fee 1:0x07ed467acd4ffd13023046968b0859781cb90d9b -f 1000000 -l 2000000 -r -o -d dealsExample.csv
    `
    )
    .action(async (vault, options) => {
      const rebateDeals = filterWildCard(await options.deals, vault);
      const offChainReferrals = filterWildCard(await options.referrals, vault);
      const result = await processVault({
        rebateDeals,
        offChainReferrals,
        readable: options.readable,
        defaultReferralRateBps: Number(options.feeRewardRate),
        defaultRebateRateBps: Number(options.feeRebateRate),
        vault,
        fromBlock: BigInt(options.fromBlock),
        toBlock: BigInt(options.toBlock),
        strictBlockNumberMatching: true,
      });

      const csv = convertToCSV({
        vault,
        data: result.data,
        pricePerShare: result.pricePerShare,
      });

      if (!options.silent) {
        console.log(csv);
      }
      if (options.output) {
        try {
          const file = Bun.file(
            `./output/user-fee/${vault.chainId}-${vault.address}-${options.fromBlock}-${options.toBlock}.csv`
          );
          await file.write(csv);
          console.log(`CSV report written to: ${file.name}`);
        } catch (error: any) {
          console.error("Error writing CSV file:", error.message);
          console.log("CSV content:");
          console.log(csv);
        }
      }
    });
}

function convertToCSV({
  vault,
  data,
  pricePerShare,
}: {
  vault: Vault;
  data: ProcessVaultReturn["data"];
  pricePerShare: number;
}) {
  const csvRows = [
    `chainId,vault,wallet,balance,fees,pricePerShare,cashback$`, // CSV header
    ...data.map(({ balance, fees, cashback, account }) => {
      if (balance === 0 && cashback == 0 && fees == 0) return "";
      let str = `${vault.chainId},${vault.address},${account},${balance},${fees}`;
      str += `,${pricePerShare},${cashback}`;
      return str;
    }),
  ];
  return csvRows.filter((row) => row !== "").join("\n");
}
